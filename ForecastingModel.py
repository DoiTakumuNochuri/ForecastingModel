# -*- coding: utf-8 -*-
"""SARIMAX_Auto2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ohh0jC0jDr3nv52V1LmfJkD6i806ZdQs
"""

# 必要なライブラリのインストール（Google Colabの場合）
!pip install pandas openpyxl matplotlib pmdarima

# ライブラリのインポート
import pandas as pd
import matplotlib.pyplot as plt
from pmdarima import auto_arima
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_absolute_error, mean_squared_error
from google.colab import files
import numpy as np

# データの読み込み
print("Excelファイルをアップロードしてください")
uploaded = files.upload()
file_name = list(uploaded.keys())[0]

# 列名を指定してデータを読み込む
data = pd.read_excel(file_name)

# 必須列名の確認
required_columns = ['Date', 'Value']
if not all(col in data.columns for col in required_columns):
    raise ValueError(f"Excel ファイルに以下の列名が必要です: {required_columns}")

# 日付列の処理
data['Date'] = pd.to_datetime(data['Date'], errors='coerce')  # 日付列を時系列型に変換
data.dropna(subset=['Date'], inplace=True)  # 欠損値の行を削除
data.set_index('Date', inplace=True)  # 日付列をインデックスに設定
ts = data['Value']  # データ列を取得

# データのプロット（元データの確認）
plt.figure(figsize=(12, 6))
plt.plot(ts, label="Original Data", color='blue')
plt.title("Original Time Series Data")
plt.legend()
plt.show()

# 手動で頻度を設定
print("""
時系列の頻度を入力してください：
- 'ME': 月末（推奨）
- 'D': 日単位
- 'Y': 年単位
- その他 pandas の頻度コードを参照
""")
freq = input("時系列の頻度を入力してください（例: 'ME', 'D', 'Y'）: ")

# リサンプリングによるデータ整形
print("データをリサンプリング中...")
if freq in ['M', 'ME', 'D', 'Y']:  # 適切な頻度を確認
    ts = ts.resample(freq).mean()  # 平均値で再サンプリング
    ts = ts.fillna(method='ffill')  # 欠損値を前方埋め
else:
    raise ValueError(f"不正な頻度コード: {freq}")

# 整形後のデータを確認
print("整形後のデータ:")
print(ts.head())
print(f"頻度: {freq}")

# データが空でないか確認
if ts.empty:
    raise ValueError("リサンプリング後の時系列データが空です。元データまたは頻度設定を確認してください。")

# SARIMAXモデルの自動チューニング
print("モデルの最適化中...")
model = auto_arima(ts, seasonal=True, m=12 if freq in ['M', 'ME'] else 1, trace=True, error_action='ignore', suppress_warnings=True, stepwise=True)

# 最適パラメータの表示
print(f"最適モデル: {model.order} SARIMAX {model.seasonal_order}")

# モデルのフィッティング
sarimax_model = SARIMAX(ts, order=model.order, seasonal_order=model.seasonal_order)
results = sarimax_model.fit(disp=False)

# 予測の準備
future_periods = int(input(f"未来の予測期間を入力してください（単位: {freq}）: "))
forecast = results.get_forecast(steps=future_periods)
forecast_values = forecast.predicted_mean
forecast_ci = forecast.conf_int()

# 予測インデックスの修正
forecast_index = pd.date_range(start=ts.index[-1] + pd.offsets.DateOffset(1), periods=future_periods, freq=freq)

# グラフのプロット（データ全体 + 予測データ）
plt.figure(figsize=(12, 6))
plt.plot(ts, label="Observed", color='blue')  # 既存データ
plt.plot(forecast_index, forecast_values, label="Forecast", color='red')  # 予測データ
plt.fill_between(forecast_index, forecast_ci.iloc[:, 0], forecast_ci.iloc[:, 1], color='pink', alpha=0.3)
plt.title("SARIMAX Forecast with Observed Data")
plt.legend()
plt.show()

# 予測精度の評価（学習データを再予測して精度を計算）
train_forecast = results.get_prediction(start=0, end=len(ts)-1)
train_forecast_values = train_forecast.predicted_mean

mae = mean_absolute_error(ts, train_forecast_values)
rmse = np.sqrt(mean_squared_error(ts, train_forecast_values))
mape = np.mean(np.abs((ts - train_forecast_values) / ts)) * 100

print(f"予測精度指標：\nMAE (Mean Absolute Error): {mae:.2f}")
print(f"RMSE (Root Mean Squared Error): {rmse:.2f}")
print(f"MAPE (Mean Absolute Percentage Error): {mape:.2f}%")

# 結果を保存
forecast_df = pd.DataFrame({
    "Date": forecast_index,
    "Forecast": forecast_values,
    "Lower CI": forecast_ci.iloc[:, 0],
    "Upper CI": forecast_ci.iloc[:, 1]
})
forecast_df.to_excel("forecast_results.xlsx", index=False)
files.download("forecast_results.xlsx")

# 必要なライブラリのインストール（Google Colabの場合）
!pip install pandas openpyxl matplotlib pmdarima

# ライブラリのインポート
import pandas as pd
import matplotlib.pyplot as plt
from pmdarima import auto_arima
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_absolute_error, mean_squared_error
from google.colab import files
import numpy as np

# データの読み込み
print("Excelファイルをアップロードしてください")
uploaded = files.upload()
file_name = list(uploaded.keys())[0]

# 列名を指定してデータを読み込む
data = pd.read_excel(file_name)

# 必須列名の確認
required_columns = ['Date', 'Value']
if not all(col in data.columns for col in required_columns):
    raise ValueError(f"Excel ファイルに以下の列名が必要です: {required_columns}")

# 日付列の処理
data['Date'] = pd.to_datetime(data['Date'], errors='coerce')  # 日付列を時系列型に変換
data.dropna(subset=['Date'], inplace=True)  # 欠損値の行を削除
data.set_index('Date', inplace=True)  # 日付列をインデックスに設定
ts = data['Value']  # データ列を取得

# データのプロット（元データの確認）
plt.figure(figsize=(12, 6))
plt.plot(ts, label="Original Data", color='blue')
plt.title("Original Time Series Data")
plt.legend()
plt.show()

# 時系列頻度の選択
print("時系列データの頻度を選択してください：")
print("1: 年単位 (Y)")
print("2: 月単位 (ME)")
print("3: 四半期 (Q)")
print("4: 日単位 (D)")
print("5: 分単位 (T)")
print("6: 秒単位 (S)")

# ユーザーの選択を取得
freq_choice = input("番号を入力してください (1-6): ")

# 選択肢に応じた頻度コードの割り当て
freq_map = {
    "1": "Y",
    "2": "ME",
    "3": "Q",
    "4": "D",
    "5": "T",
    "6": "S"
}

# 頻度の設定
if freq_choice not in freq_map:
    raise ValueError("無効な選択です。1～6の番号を入力してください。")
freq = freq_map[freq_choice]

# リサンプリングによるデータ整形
print(f"選択された頻度: {freq}. データをリサンプリング中...")
ts = ts.resample(freq).mean()  # 平均値で再サンプリング
ts = ts.fillna(method='ffill')  # 欠損値を前方埋め

# 整形後のデータを確認
print("整形後のデータ:")
print(ts.head())
print(f"頻度: {freq}")

# データが空でないか確認
if ts.empty:
    raise ValueError("リサンプリング後の時系列データが空です。元データまたは頻度設定を確認してください。")

# SARIMAXモデルの自動チューニング
print("モデルの最適化中...")
model = auto_arima(ts, seasonal=True, m=4 if freq in ['Q', 'QS'] else (12 if freq in ['ME', 'M'] else 1), trace=True, error_action='ignore', suppress_warnings=True, stepwise=True)

# 最適パラメータの表示
print(f"最適モデル: {model.order} SARIMAX {model.seasonal_order}")

# モデルのフィッティング
sarimax_model = SARIMAX(ts, order=model.order, seasonal_order=model.seasonal_order)
results = sarimax_model.fit(disp=False)

# 予測の準備
future_periods = int(input(f"未来の予測期間を入力してください（単位: {freq}）: "))
forecast = results.get_forecast(steps=future_periods)
forecast_values = forecast.predicted_mean
forecast_ci = forecast.conf_int()

# 予測インデックスの修正
forecast_index = pd.date_range(start=ts.index[-1] + pd.offsets.DateOffset(1), periods=future_periods, freq=freq)

# グラフのプロット（データ全体 + 予測データ）
plt.figure(figsize=(12, 6))
plt.plot(ts, label="Observed", color='blue')  # 既存データ
plt.plot(forecast_index, forecast_values, label="Forecast", color='red')  # 予測データ
plt.fill_between(forecast_index, forecast_ci.iloc[:, 0], forecast_ci.iloc[:, 1], color='pink', alpha=0.3)
plt.title("SARIMAX Forecast with Observed Data")
plt.legend()
plt.show()

# 予測精度の評価（学習データを再予測して精度を計算）
train_forecast = results.get_prediction(start=0, end=len(ts)-1)
train_forecast_values = train_forecast.predicted_mean

mae = mean_absolute_error(ts, train_forecast_values)
rmse = np.sqrt(mean_squared_error(ts, train_forecast_values))
mape = np.mean(np.abs((ts - train_forecast_values) / ts)) * 100

print(f"予測精度指標：\nMAE (Mean Absolute Error): {mae:.2f}")
print(f"RMSE (Root Mean Squared Error): {rmse:.2f}")
print(f"MAPE (Mean Absolute Percentage Error): {mape:.2f}%")

# 結果を保存
forecast_df = pd.DataFrame({
    "Date": forecast_index,
    "Forecast": forecast_values,
    "Lower CI": forecast_ci.iloc[:, 0],
    "Upper CI": forecast_ci.iloc[:, 1]
})
forecast_df.to_excel("forecast_results.xlsx", index=False)
files.download("forecast_results.xlsx")



